syntax = "proto3";

package s2.v1alpha;

import "google/protobuf/field_mask.proto";

option java_multiple_files = true;
option java_package = "s2.v1alpha";

// Operate on an S2 account.
service AccountService {
  // List basins.
  rpc ListBasins(ListBasinsRequest) returns (ListBasinsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Create a new basin.
  // Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
  rpc CreateBasin(CreateBasinRequest) returns (CreateBasinResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Delete a basin.
  // Basin deletion is asynchronous, and may take a few minutes to complete.
  rpc DeleteBasin(DeleteBasinRequest) returns (DeleteBasinResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Update basin configuration.
  rpc ReconfigureBasin(ReconfigureBasinRequest) returns (ReconfigureBasinResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Get basin configuration.
  rpc GetBasinConfig(GetBasinConfigRequest) returns (GetBasinConfigResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Issue a new access token.
  rpc IssueAccessToken(IssueAccessTokenRequest) returns (IssueAccessTokenResponse);

  // Revoke an access token.
  rpc RevokeAccessToken(RevokeAccessTokenRequest) returns (RevokeAccessTokenResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // List access tokens.
  rpc ListAccessTokens(ListAccessTokensRequest) returns (ListAccessTokensResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

// Operate on an S2 basin.
service BasinService {
  // List streams.
  rpc ListStreams(ListStreamsRequest) returns (ListStreamsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Create a stream.
  // Provide a client request token with the `S2-Request-Token` header for idempotent retry behaviour.
  rpc CreateStream(CreateStreamRequest) returns (CreateStreamResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Delete a stream.
  // Stream deletion is asynchronous, and may take a few minutes to complete.
  rpc DeleteStream(DeleteStreamRequest) returns (DeleteStreamResponse) {
    option idempotency_level = IDEMPOTENT;
  }

  // Get stream configuration.
  rpc GetStreamConfig(GetStreamConfigRequest) returns (GetStreamConfigResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Update stream configuration.
  rpc ReconfigureStream(ReconfigureStreamRequest) returns (ReconfigureStreamResponse) {
    option idempotency_level = IDEMPOTENT;
  }
}

// Operate on an S2 stream.
service StreamService {
  // Check the sequence number that will be assigned to the next record on a stream.
  rpc CheckTail(CheckTailRequest) returns (CheckTailResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Append a batch of records to a stream.
  rpc Append(AppendRequest) returns (AppendResponse);

  // Append batches of records to a stream continuously, while guaranteeing pipelined requests are processed in order.
  // If any request fails, the session is terminated.
  rpc AppendSession(stream AppendSessionRequest) returns (stream AppendSessionResponse);

  // Retrieve a batch of records from a stream.
  rpc Read(ReadRequest) returns (ReadResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // Retrieve batches of records from a stream continuously.
  rpc ReadSession(ReadSessionRequest) returns (stream ReadSessionResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

/// AccountService ///

// List basins request.
message ListBasinsRequest {
  // List basin names that begin with this prefix.
  string prefix = 1;
  // Only return basins names that lexicographically start after this name.
  // This can be the last basin name seen in a previous listing, to continue from there.
  // It must be greater than or equal to the prefix if specified.
  string start_after = 2;
  // Number of results, up to a maximum of 1000.
  optional uint64 limit = 3;
}

// List basins response.
message ListBasinsResponse {
  // Matching basins.
  repeated BasinInfo basins = 1;
  // If set, indicates there are more results that can be listed with `start_after`.
  bool has_more = 2;
}

// Create basin request.
message CreateBasinRequest {
  // Basin name, which must be globally unique. It can be omitted to let the service assign a unique name.
  // The name must be between 8 and 48 characters, comprising lowercase letters, numbers and hyphens.
  // It cannot begin or end with a hyphen.
  string basin = 1;
  // Basin configuration.
  BasinConfig config = 2;
  // Basin scope.
  BasinScope scope = 3;
}

// Basin scope.
enum BasinScope {
  // Unspecified basin scope.
  BASIN_SCOPE_UNSPECIFIED = 0;
  // aws us-east-1 region.
  BASIN_SCOPE_AWS_US_EAST_1 = 1;
}

// Create basin response.
message CreateBasinResponse {
  // Information about the newly created basin.
  BasinInfo info = 1;
}

// Delete basin request.
message DeleteBasinRequest {
  // Name of the basin to delete.
  string basin = 1;
}

// Delete basin response.
message DeleteBasinResponse {}

// Get basin configuration request.
message GetBasinConfigRequest {
  // Basin name.
  string basin = 1;
}

// Get basin configuration response.
message GetBasinConfigResponse {
  // Basin configuration.
  BasinConfig config = 1;
}

// Reconfigure basin request.
message ReconfigureBasinRequest {
  // Basin name.
  string basin = 1;
  // Basin configuration.
  BasinConfig config = 2;
  // Specifies the pieces of configuration being updated.
  // See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  google.protobuf.FieldMask mask = 3;
}

// Reconfigure basin response.
message ReconfigureBasinResponse {
  // Basin configuration.
  BasinConfig config = 1;
}

// Issue access token request.
message IssueAccessTokenRequest {
  // Access token information.
  AccessTokenInfo info = 1;
}

// API operations.
enum Operation {
  // Unspecified operation.
  OPERATION_UNSPECIFIED = 0;
  // List basins.
  OPERATION_LIST_BASINS = 1;
  // Create a basin.
  OPERATION_CREATE_BASIN = 2;
  // Delete a basin.
  OPERATION_DELETE_BASIN = 3;
  // Update basin configuration.
  OPERATION_RECONFIGURE_BASIN = 4;
  // Get basin configuration.
  OPERATION_GET_BASIN_CONFIG = 5;
  // Issue an access token.
  OPERATION_ISSUE_ACCESS_TOKEN = 6;
  // Revoke an access token.
  OPERATION_REVOKE_ACCESS_TOKEN = 7;
  // List access tokens.
  OPERATION_LIST_ACCESS_TOKENS = 8;
  // List streams.
  OPERATION_LIST_STREAMS = 9;
  // Create a stream.
  OPERATION_CREATE_STREAM = 10;
  // Delete a stream.
  OPERATION_DELETE_STREAM = 11;
  // Get stream configuration.
  OPERATION_GET_STREAM_CONFIG = 12;
  // Update stream configuration.
  OPERATION_RECONFIGURE_STREAM = 13;
  // Check tail of a stream.
  OPERATION_CHECK_TAIL = 14;
  // Append records to a stream.
  OPERATION_APPEND = 15;
  // Read records from a stream.
  OPERATION_READ = 16;
}

// Read/Write permissions.
message ReadWritePermissions {
  // Read permission.
  bool read = 1;
  // Write permission.
  bool write = 2;
}

// Access permissions for a group.
message PermittedOperationGroups {
  // Access permissions at account level.
  ReadWritePermissions account = 1;
  // Access permissions at basin level.
  ReadWritePermissions basin = 2;
  // Access permissions at stream level.
  ReadWritePermissions stream = 3;
}

// Revoke access token request.
message RevokeAccessTokenRequest {
  // Token to revoke.
  string id = 1;
}

// Revoke access token response.
message RevokeAccessTokenResponse {
  // Access token information.
  AccessTokenInfo info = 1;
}

// List access tokens request.
message ListAccessTokensRequest {
  // List access tokens that begin with this prefix.
  string prefix = 1;
  // Only return access tokens that lexicographically start after this token ID.
  string start_after = 2;
  // Number of results, up to a maximum of 1000.
  optional uint64 limit = 3;
}

// List access tokens response.
message ListAccessTokensResponse {
  // Access tokens information.
  repeated AccessTokenInfo tokens = 1;
  // If set, indicates there are more results that can be listed with `start_after`.
  bool has_more = 2;
}

// Access token information.
message AccessTokenInfo {
  // Access token ID.
  string id = 1;
  // Expiration time in seconds since Unix epoch.
  optional uint32 expires_at = 2;
  // Namespace streams based on the configured stream-level scope, which must be a prefix.
  // Stream name arguments will be automatically prefixed, and the prefix will be stripped
  // when listing streams.
  bool auto_prefix_streams = 3;
  // Access token scope.
  AccessTokenScope scope = 4;
}

// Access token scope.
message AccessTokenScope {
  // Access permissions at basin level.
  ResourceSet basins = 1;
  // Access permissions at stream level.
  ResourceSet streams = 2;
  // Access permissions at token level.
  ResourceSet tokens = 3;
  // Access permissions at operation group level.
  PermittedOperationGroups op_groups = 4;
  // Operations allowed for the token.
  // A union of allowed operations and groups is used as an effective set of allowed operations.
  repeated Operation ops = 5;
}

// Set of named resources.
message ResourceSet {
  // Matching rule.
  oneof matching {
    // Match only the resource with this exact name.
    string exact = 1;
    // Match all resources that start with this prefix.
    string prefix = 2;
  }
}

// Issue access token response.
message IssueAccessTokenResponse {
  // Created token.
  string token = 1;
}

/// BasinService ///

// Stream information.
message StreamInfo {
  // Stream name.
  string name = 1;
  // Creation time in seconds since Unix epoch.
  uint32 created_at = 2;
  // Deletion time in seconds since Unix epoch, if the stream is being deleted.
  optional uint32 deleted_at = 3;
}

// List streams request.
message ListStreamsRequest {
  // List stream names that begin with this prefix.
  string prefix = 1;
  // Only return stream names that lexicographically start after this name.
  // This can be the last stream name seen in a previous listing, to continue from there.
  // It must be greater than or equal to the prefix if specified.
  string start_after = 2;
  // Number of results, up to a maximum of 1000.
  optional uint64 limit = 3;
}

// List streams response.
message ListStreamsResponse {
  // Matching streams.
  repeated StreamInfo streams = 1;
  // If set, indicates there are more results that can be listed with `start_after`.
  bool has_more = 2;
}

// Create stream request.
message CreateStreamRequest {
  // Stream name, which must be unique within the basin.
  // It can be an arbitrary string upto 512 characters.
  // Backslash (`/`) is recommended as a delimiter for hierarchical naming.
  string stream = 1;
  // Configuration for the new stream.
  StreamConfig config = 2;
}

// Create stream response.
message CreateStreamResponse {
  // Information about the newly created stream.
  StreamInfo info = 1;
}

// Delete stream request.
message DeleteStreamRequest {
  // Stream name.
  string stream = 1;
}

// Delete stream response.
message DeleteStreamResponse {}

// Get stream configuration request.
message GetStreamConfigRequest {
  // Stream name.
  string stream = 1;
}

// Get stream configuration response.
message GetStreamConfigResponse {
  // Stream configuration.
  StreamConfig config = 1;
}

// Reconfigure stream request.
message ReconfigureStreamRequest {
  // Stream name.
  string stream = 1;
  // Stream configuration with updated values.
  StreamConfig config = 2;
  // Specifies the pieces of configuration being updated.
  // See https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask
  google.protobuf.FieldMask mask = 3;
}

// Reconfigure stream response.
message ReconfigureStreamResponse {
  // Stream configuration.
  StreamConfig config = 1;
}

/// StreamService ///

// Check tail request.
message CheckTailRequest {
  // Stream name.
  string stream = 1;
}

// Check tail response.
message CheckTailResponse {
  // Sequence number that will be assigned to the next record on the stream.
  uint64 next_seq_num = 1;
}

// Input for append requests.
message AppendInput {
  // Stream name. Optional for subsequent requests in the session.
  string stream = 1;
  // Batch of records to append atomically, which must contain at least one record, and no more than 1000.
  // The total size of a batch of records may not exceed 1MiB of metered bytes.
  repeated AppendRecord records = 2;
  // Enforce that the sequence number issued to the first record matches.
  optional uint64 match_seq_num = 3;
  // Enforce a fencing token which must have been previously set by a `fence` command record.
  optional bytes fencing_token = 4;
}

// Output from append response.
message AppendOutput {
  // Sequence number of first record appended.
  uint64 start_seq_num = 1;
  // Sequence number of last record appended + 1.
  // `end_seq_num - start_seq_num` will be the number of records in the batch.
  uint64 end_seq_num = 2;
  // Sequence number of last durable record on the stream + 1.
  // This can be greater than `end_seq_num` in case of concurrent appends.
  uint64 next_seq_num = 3;
}

// Append request.
message AppendRequest {
  // Request parameters for an append.
  AppendInput input = 1;
}

// Append response.
message AppendResponse {
  // Response details for an append.
  AppendOutput output = 1;
}

// Append session request.
message AppendSessionRequest {
  // Request parameters for an append.
  AppendInput input = 1;
}

// Append session response.
message AppendSessionResponse {
  // Response details for an append.
  AppendOutput output = 1;
}

// Output from read response.
message ReadOutput {
  // Batch of records, or a sequence number if the read could not be satisfied.
  // An empty batch or a sequence number output will be a terminal message in a session.
  oneof output {
    // Batch of records.
    // It can only be empty when not in a session context (which implies a limit),
    // if the first record that could have been retrieved would violate the limit.
    SequencedRecordBatch batch = 1;
    // Sequence number for the first record on this stream.
    // Typically this will be returned when the requested `start_seq_num` was smaller.
    // It may also be returned during a session, if the stream gets concurrently trimmed.
    uint64 first_seq_num = 2;
    // Sequence number that will be assigned to the next record on this stream.
    // This will be returned either because the requested `start_seq_num` was larger,
    // or in case of a limited read, equal to it.
    uint64 next_seq_num = 3;
  }
}

// Read request.
message ReadRequest {
  // Stream name.
  string stream = 1;
  // Starting sequence number (inclusive).
  uint64 start_seq_num = 2;
  // Limit how many records can be returned.
  // This will get capped at the default limit,
  // which is up to 1000 records or 1MiB of metered bytes.
  ReadLimit limit = 3;
}

// Read response.
message ReadResponse {
  // Response details for a read.
  ReadOutput output = 1;
}

// If both count and bytes are specified, either limit may be hit.
message ReadLimit {
  // Record count limit.
  optional uint64 count = 1;
  // Metered bytes limit.
  optional uint64 bytes = 2;
}

// Read session request.
message ReadSessionRequest {
  // Stream name.
  string stream = 1;
  // Starting sequence number (inclusive).
  uint64 start_seq_num = 2;
  // Limit on how many records can be returned. When a limit is specified, the session will be terminated as soon as
  // the limit is met, or when the current tail of the stream is reached -- whichever occurs first.
  // If no limit is specified, the session will remain open after catching up to the tail, and continue tailing as
  // new messages are written to the stream.
  ReadLimit limit = 3;
  // Heartbeats can be enabled to monitor end-to-end session health.
  // A heartbeat will be sent when the initial switch to real-time tailing happens,
  // as well as when no records are available at a randomized interval between 5 and 15 seconds.
  bool heartbeats = 4;
}

// Read session response.
message ReadSessionResponse {
  // Response details for a read.
  // This will not be set in case of a heartbeat message.
  optional ReadOutput output = 1;
}

/// Common types ///

// Storage class for recent writes.
enum StorageClass {
  // Unspecified, which is currently overridden to `STORAGE_CLASS_EXPRESS`.
  STORAGE_CLASS_UNSPECIFIED = 0;
  // Standard, which offers end-to-end latencies under 500 ms.
  STORAGE_CLASS_STANDARD = 1;
  // Express, which offers end-to-end latencies under 50 ms.
  STORAGE_CLASS_EXPRESS = 2;
}

// Stream configuration.
message StreamConfig {
  // Storage class for recent writes. This is the main cost:performance knob in S2.
  StorageClass storage_class = 1;
  // Retention policy for the stream.
  // If unspecified, the default is to retain records for 7 days.
  oneof retention_policy {
    // Age in seconds for automatic trimming of records older than this threshold.
    // If set to 0, the stream will have infinite retention.
    uint64 age = 2;
  }
  // Controls how to handle timestamps when they are not provided by the client.
  // If this is false (or not set), the record's arrival time will be assigned as its timestamp.
  // If this is true, then any append without a client-specified timestamp will be rejected as invalid.
  optional bool require_client_timestamps = 3;
}

// Basin configuration.
message BasinConfig {
  // Default stream configuration.
  StreamConfig default_stream_config = 1;
  // Create stream on append if it doesn't exist,
  // using the default stream configuration.
  bool create_stream_on_append = 2;
}

// Current state of the basin.
enum BasinState {
  // Unspecified.
  BASIN_STATE_UNSPECIFIED = 0;
  // Basin is active.
  BASIN_STATE_ACTIVE = 1;
  // Basin is being created.
  BASIN_STATE_CREATING = 2;
  // Basin is being deleted.
  BASIN_STATE_DELETING = 3;
}

// Basin information.
message BasinInfo {
  // Basin name.
  string name = 1;
  // Basin scope.
  BasinScope scope = 5;
  // Basin state.
  BasinState state = 4;
}

// Headers add structured information to a record as name-value pairs.
message Header {
  // Header name blob.
  // The name cannot be empty, with the exception of an S2 command record.
  bytes name = 1;
  // Header value blob.
  bytes value = 2;
}

// Record to be appended to a stream.
message AppendRecord {
  // Timestamp for this record in milliseconds since Unix epoch.
  // The service ensures monotonicity by adjusting it up if necessary to the maximum observed timestamp.
  // A timestamp detected to be in the future will be adjusted down.
  // If not provided, the semantics depend on the stream's `require_client_timestamps` config.
  optional uint64 timestamp = 3;
  // Series of name-value pairs for this record.
  repeated Header headers = 1;
  // Body of this record.
  bytes body = 2;
}

// Record retrieved from a stream.
message SequencedRecord {
  // Sequence number assigned to this record.
  uint64 seq_num = 1;
  // Timestamp for this record in milliseconds since Unix epoch.
  uint64 timestamp = 4;
  // Series of name-value pairs for this record.
  repeated Header headers = 2;
  // Body of this record.
  bytes body = 3;
}

// A batch of sequenced records.
message SequencedRecordBatch {
  // Batch of sequenced records.
  repeated SequencedRecord records = 1;
}
